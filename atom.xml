<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://blog.leepanda.top</id>
    <title>戏</title>
    <updated>2021-05-29T11:29:42.721Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://blog.leepanda.top"/>
    <link rel="self" href="https://blog.leepanda.top/atom.xml"/>
    <logo>https://blog.leepanda.top/images/avatar.png</logo>
    <icon>https://blog.leepanda.top/favicon.ico</icon>
    <rights>All rights reserved 2021, 戏</rights>
    <entry>
        <title type="html"><![CDATA[随想：记忆与时间]]></title>
        <id>https://blog.leepanda.top/post/sui-xiang-ji-yi-yu-shi-jian/</id>
        <link href="https://blog.leepanda.top/post/sui-xiang-ji-yi-yu-shi-jian/">
        </link>
        <updated>2021-05-29T11:22:38.000Z</updated>
        <content type="html"><![CDATA[<p>被软件推广忽悠一次后 ，开始反思自己买过、下载过的软件中，使用率最高、最值的是哪一个？<br>
印象笔记。<br>
大学的时候，开始使用CSDN做学习笔记、Chrome收藏来记录精彩文章、IPad记录思考过程和琐碎Tips 大量使用<code>磁质媒介</code>记录信息 可以说，从高中毕业之后，我就很少主动使用大脑去记忆了。<br>
直到我忘记昨天同事做了项目分享</p>
<h3 id="大脑应该记住啥">大脑应该记住啥</h3>
<blockquote>
<p>《白夜追凶》中一个经验尚浅的罪犯，面对警方的盘问，说出了准备良久的生活足迹。 警方反而以此确认了他的嫌疑  因为没有一个正常人会记得自己上周二下午4点在干啥。</p>
</blockquote>
<p>它想说，遗忘是人之常情...<br>
...但是，所有遗忘都情有可原吗</p>
<ul>
<li>
<p>特定内容<br>
与重要之人的互动、父母和朋友的生日<br>
昨天为啥觉得自己是个傻逼，女朋友不开心的原因<br>
工作中遇到的一个可优化点<br>
这些都不应该忘记</p>
</li>
<li>
<p>较宽松的清晰度<br>
如果说回忆上周二下午4点这种精准时间难度太大，<br>
那么去年4季度我干了啥这种段时间的大事记<br>
是否也容许答不上来</p>
</li>
<li>
<p>记忆和时间的关系是什么？<br>
我尝试在大脑里寻找这个月的回忆，<br>
发现它们已经十分模糊、碎成了渣。</p>
</li>
</ul>
<ol>
<li>
<p>和她一起跨年的夜晚，走到膝盖疼。天桥上看着她的眼睛，在车流声和冬夜微风中吃咖喱盒饭。</p>
</li>
<li>
<p>我的研究有了巨大突破，极乐冲击着大脑。血脉贲张<br>
研究成果上报后，却发现它已经被发现时的失落。</p>
</li>
<li>
<p>少华的EZ居然能丝血反杀</p>
</li>
<li>
<p>一整天都花在通勤上的周五。飞机降落时，耳膜的痛苦。</p>
</li>
<li>
<p>运维项目时的期待。修缮源码时的无奈。</p>
</li>
<li>
<p>蹲起后肌肉拉伸时，令人昏厥的快感<br>
就这些了...<br>
除此之外，我竟想不起这个月其他事情。<br>
所以我是度过了一个月，还是度过了这6个片段？<br>
...<br>
我大胆猜想<br>
如果拿掉 年、月、日，小时、分钟、秒 这些<br>
人类通过协商共识  创造的 统一度量衡。<br>
真正属于我自己的计时单位，会是什么<br>
是 脑内记忆片段。<br>
是 能回忆起来的 感觉。<br>
客观上,以人类公认计时法，从1月1日 到 1月27日，间隔27天。<br>
但对于我自己，只间隔 6片记忆。<br>
如何利用该方法论<br>
&quot;生命的意义在于获得时间&quot; ---- 《超体》</p>
</li>
</ol>
<p>人类社会现行时间计法，以 秒作为基本单位，<br>
其他单位年、月、日 均是从秒定义而来<br>
而秒的定义本身则是<br>
铯133原子基态的两个超精细能阶之间跃迁时所辐射的电磁波的周期的9,192,631,770倍的时间。<br>
只要我们等待铯133原子跃迁更多次，<br>
就能获取 人类文明现行时间计法 下，更多的时间。</p>
<p>那么，对应到主观感觉计时法<br>
我们需要怎么做，才能获得更多时间呢...</p>
<p>很明显就不是等待了<br>
而是要 主动经历、主动生成并体会感觉<br>
我们需要愤怒、需要焦虑<br>
需要欢悦、需要乐极而悲<br>
需要 主动去追逐 新鲜的体验， 尽力用大脑记住这些精彩的感觉。</p>
<p>比如说</p>
<blockquote>
<p>现在，凌晨三点半<br>
我很困<br>
半死不活地摊在椅子上<br>
疑惑且小害怕——身上的痘痘怎么变多了<br>
晃着腿<br>
写着一些胡说八道、不清楚的东西，<br>
希望发到知乎上得到共鸣，但又怕别人说我中二。<br>
但其实根本没啥人看<br>
同时还有点口渴<br>
只要记住上述 压抑且混乱的 感觉，<br>
我度过的时间就变长了。<br>
从 6片记忆 延长到了 7片记忆</p>
</blockquote>
<h3 id="总结与疑问">总结与疑问</h3>
<p>总而言之，我猜想，<br>
通过用大脑而非印象笔记来记忆感觉<br>
会在主观上，延长时间<br>
同时在文章最后引出疑问：<br>
阅读、看视频、听音乐 等。从艺术作品中，得到的感觉，会让时间变长么<br>
反刍之前体会过的感觉，这个回忆行为本身，能延长时间么</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[机器学习[2]:模型评估]]></title>
        <id>https://blog.leepanda.top/post/ji-qi-xue-xi-2mo-xing-ping-gu/</id>
        <link href="https://blog.leepanda.top/post/ji-qi-xue-xi-2mo-xing-ping-gu/">
        </link>
        <updated>2021-05-29T11:21:06.000Z</updated>
        <content type="html"><![CDATA[<p>对生成的模型进行比较，以得到最好的训练结果。需要使用评估算法进行评估。</p>
<h3 id="评估算法">评估算法</h3>
<ul>
<li>分离训练数据集和评估数据集
<ul>
<li>66.7% + 33.3%</li>
</ul>
</li>
<li>K折交叉验证分离
<ul>
<li>把data分为K组，每组都单独做一次 validation_data</li>
</ul>
</li>
<li>弃一交叉验证分离
<ul>
<li>data中的每一个数据，都做一次validation</li>
</ul>
</li>
<li>重复随机评估
<ul>
<li>随机分组，作validation</li>
</ul>
</li>
</ul>
<h3 id="混淆矩阵相关">混淆矩阵相关</h3>
<h4 id="图形分类">图形分类</h4>
<ul>
<li>错误率</li>
<li>Accurancy</li>
<li>Precision</li>
<li>Recall</li>
<li>F1-Score</li>
<li>TPR</li>
<li>FPR</li>
<li>PRC曲线
<ul>
<li>Precision作Y，Recall作X</li>
<li>曲线下方面积为1时，性能最理想。</li>
</ul>
</li>
<li>ROC曲线
<ul>
<li>TPR作Y，FPR作X</li>
<li>AUC曲线的Y值为ROC曲线下方的面积</li>
<li>曲线越靠左上，性能越好</li>
</ul>
</li>
</ul>
<h4 id="目标检测">目标检测</h4>
<ul>
<li>IOU</li>
<li>AP</li>
<li>mAP</li>
</ul>
<h4 id="回归类型">回归类型</h4>
<ul>
<li>MAE</li>
<li>RMSE</li>
</ul>
<h3 id="reference">Reference</h3>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/74493056">常见的模型算法评估指标 - 人工智能技术干货的文章 - 知乎</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[机器学习[1]:特征选择]]></title>
        <id>https://blog.leepanda.top/post/ji-qi-xue-xi-1te-zheng-xuan-ze/</id>
        <link href="https://blog.leepanda.top/post/ji-qi-xue-xi-1te-zheng-xuan-ze/">
        </link>
        <updated>2021-05-29T11:19:34.000Z</updated>
        <content type="html"><![CDATA[<p>数据和特征 限定了机器学习性能的上限，优化 模型和算法 来逼近这个上限</p>
<h3 id="特征处理">特征处理</h3>
<ul>
<li>预处理</li>
<li>特征选择</li>
<li>降维</li>
</ul>
<h3 id="特征选择的意义">特征选择的意义</h3>
<ul>
<li>降低拟合度</li>
<li>预测结果更精确</li>
<li>减少模型训练时间</li>
</ul>
<p>无关的特征会降低魔性的额准确度，尤其是线性算法(线性回归算法、逻辑回归算法)</p>
<h3 id="特征选择的方法">特征选择的方法</h3>
<ul>
<li>单变量特征选择</li>
<li>递归特征消除 RFE</li>
<li>主要成分分析 PCA</li>
<li>特征重要性</li>
</ul>
<h3 id="单变量特征选择">单变量特征选择</h3>
<ul>
<li>卡方检验法</li>
<li>相关系数法</li>
<li>互信息法</li>
</ul>
<p>卡方检验法代码</p>
<pre><code class="language-python">#coding=utf-8
from pandas import read_csv
from numpy import set_printoptions
from sklearn.feature_selection import SelectKBest
from sklearn.feature_selection import chi2

# 导入数据
filename = 'iris.data'
names = ['separ-length', 'separ-width', 'petal-length', 'petal-width', 'class']
data = read_csv(filename, names=names)
array = data.values

X = array[:, 0:4] # 输入数据
Y = array[:,4] # 输出结果

ret=SelectKBest(score_func=chi2, k=2).fit(X,Y)
print(ret.scores_) # 分数最高的那个属性 就是 最有决定性的特征
features = ret.transform(X)
print(features) # 查看分数最高的那K个属性 对应的数据
#print(fit.scores_)
</code></pre>
<h3 id="递归特征消除">递归特征消除</h3>
<ul>
<li>线性回归</li>
<li>逻辑回归</li>
</ul>
<p>逻辑回归法代码</p>
<pre><code class="language-python">from pandas import read_csv
from sklearn.feature_selection import RFE 
from sklearn.linear_model import LogisticRegression

filename = &quot;./iris.data&quot;
names = ['separ-length', 'separ-width', 'petal-length', 'petal-width', 'class']
array = read_csv(filename, names=names).values

X=array[:,0:4]
Y=array[:,4]

model=LogisticRegression()
fit = RFE(model, 1).fit(X,Y)
print(&quot;所有特征:&quot;)
print(fit.n_features_)
print(&quot;被选中的特征:&quot;)
print(fit.support_)
print(&quot;特征排名&quot;)
print(fit.ranking_)
</code></pre>
<h3 id="主要成分分析">主要成分分析</h3>
<ul>
<li>PCA</li>
<li>LDA</li>
</ul>
<p>PCA算法代码</p>
<pre><code>from pandas import read_csv
from sklearn.decomposition import PCA

filename = &quot;./iris.data&quot;
names = ['separ-length', 'separ-width', 'petal-length', 'petal-width', 'class']
array = read_csv(filename,names=names).values

X = array[:,0:4]
Y = array[:,4]

fit = PCA(n_components=1).fit(X)
print(fit.components_)
</code></pre>
<h3 id="特征重要性">特征重要性</h3>
<ul>
<li>袋装决策树算法</li>
<li>随机森林算法</li>
<li>极端随机树算法</li>
</ul>
<p>极端随机树算法代码</p>
<pre><code class="language-python">from pandas import read_csv
from sklearn.ensemble import ExtraTreesClassifier

filename = &quot;./iris.data&quot;
names = ['separ-length', 'separ-width', 'petal-length', 'petal-width', 'class']
array = read_csv(filename, names=names).values

X=array[:,0:4]
Y=array[:,4]

fit = ExtraTreesClassifier().fit(X,Y)
print(fit.feature_importances_)
</code></pre>
<h3 id="总结">总结</h3>
<p>上述代码都可以评估出，蝴蝶花的花瓣长度 是最能确定蝴蝶花种类的属性。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[软件工程备考简答题总结]]></title>
        <id>https://blog.leepanda.top/post/ruan-jian-gong-cheng-bei-kao-jian-da-ti-zong-jie/</id>
        <link href="https://blog.leepanda.top/post/ruan-jian-gong-cheng-bei-kao-jian-da-ti-zong-jie/">
        </link>
        <updated>2021-05-29T11:17:48.000Z</updated>
        <content type="html"><![CDATA[<p>此版本复习提纲仅适用于 江苏大学陈雷老师班</p>
<h3 id="第一章-软件工程概述">第一章 软件工程概述</h3>
<ul>
<li>
<p>软件的特点</p>
<ul>
<li>无法观察物理形态</li>
<li>在软件的开发过程、工程管理过程中渗透了大量的脑力劳动</li>
<li>无磨损、老化</li>
<li>需要在特定的计算机系统环境下运行</li>
<li>有复用性</li>
</ul>
</li>
<li>
<p>软件工程的提出目的是:</p>
<ul>
<li>解决软件危机带来的诸多弊端
<ul>
<li>控制开发成本在预期范围内</li>
<li>交付满足用户需求的软件</li>
<li>软件的功能可靠</li>
<li>软件的品质优秀</li>
<li>控制软件的开发时间</li>
<li>软件易于维护</li>
</ul>
</li>
</ul>
</li>
<li>
<p>目标、过程、原则</p>
<ul>
<li>目标：低成本、高品质、及时交付软件</li>
<li>过程：基本过程、支持过程、组织过程</li>
<li>原则：
<ul>
<li>适宜的开发泛型</li>
<li>适宜的设计方法</li>
<li>高品质的工程支持</li>
<li>开发过程的管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第二章-开发模型">第二章 开发模型</h3>
<ul>
<li>
<p>四种开发模型的对比</p>
<ul>
<li>瀑布模型
<ul>
<li>顺序执行、不可回退</li>
</ul>
</li>
<li>快速原型模型
<ul>
<li>快速获取用户的需求</li>
</ul>
</li>
<li>增量模型
<ul>
<li>产品灵活可以变更需求</li>
</ul>
</li>
<li>螺旋模型
<ul>
<li>在 快速原型模型 和 增量模型的基础上 添加了 风险管理</li>
</ul>
</li>
</ul>
</li>
<li>
<p>XP模型</p>
<ul>
<li>客户参与、适应变化、测试驱动、以代码为核心</li>
</ul>
</li>
<li>
<p>敏捷思想的核心价值观</p>
<ul>
<li>注重个人和交互</li>
<li>注重能工作的软件</li>
<li>提高客户的参与程度</li>
<li>以积极的心态响应需求变化</li>
</ul>
</li>
</ul>
<h3 id="第三章-需求分析">第三章 需求分析</h3>
<ul>
<li>
<p>结构化的具体步骤如下:</p>
<ul>
<li>建立当前系统的具体模型</li>
<li>生成当前系统的逻辑模型</li>
<li>建立目标系统的逻辑模型</li>
</ul>
</li>
<li>
<p>需求分析的过程：</p>
<ul>
<li>需求获取:调查软件需求</li>
<li>需求分析:分析建模、对现实世界进行抽象</li>
<li>需求说明:编写需求文档</li>
<li>需求验证:需求评审</li>
</ul>
</li>
<li>
<p>人们对事物的认识是不断深化的，因此需求迭代是一个过程。</p>
<ul>
<li>这种迭代存在风险，会使上一次迭代因为需求不足而被推翻</li>
<li>软件分析师应意识到迭代中风险的必然性。积极面对需求变更</li>
</ul>
</li>
<li>
<p>评审的作用</p>
<ul>
<li>作用:为了尽早消除需求中的错误，确保需求说明的准确、完整</li>
<li>必要性:需求说明书中都是自然语言，需要确定语言的准确</li>
</ul>
</li>
<li>
<p>数据流图的作用</p>
<ul>
<li>抽象的表示系统和软件</li>
<li>从信息加工的角度，自顶向下、逐步求精的表示功能细节</li>
<li>提供了功能建模的机制 、 信息流建模的机制</li>
<li>建立起系统或软件的功能模型</li>
</ul>
</li>
</ul>
<h3 id="第四章-软件设计">第四章 软件设计</h3>
<ul>
<li>
<p>软件设计</p>
<ul>
<li>输入：需求规格说明书</li>
<li>输出：设计规格说明书</li>
<li>目标：需求模型转设计模型</li>
<li>过程：层层分解、逐步求精</li>
</ul>
</li>
<li>
<p>软件设计是对软件需求进行：</p>
<ul>
<li>数据设计</li>
<li>体系结构设计</li>
<li>接口设计</li>
<li>构件设计</li>
<li>部署设计</li>
</ul>
</li>
<li>
<p>软件设计优化的准则如下:</p>
<ul>
<li>相关的各部分放到一起、不相关的不放到一起</li>
<li>模块的大小要适中</li>
<li>模块的接口简明扼要</li>
<li>作用范围在控制范围内</li>
<li>软件的深度、宽度、扇入扇出要适当</li>
<li>单入口、单出口</li>
<li>可预测模块的划分</li>
</ul>
</li>
</ul>
<h3 id="第五章-测试">第五章 测试</h3>
<ul>
<li>
<p>测试和调试的不同</p>
<ul>
<li>测试：尽可能发现错误</li>
<li>调试：尽可能修复错误</li>
</ul>
</li>
<li>
<p>静态测试和动态测试的不同</p>
<ul>
<li>静态测试：人工审计、仔细阅读文档、检查软件的执行情况是否与设计规格说明书一致</li>
<li>动态测试：依赖软件的执行、测试用例来判断是否符合设计规格说明书</li>
</ul>
</li>
<li>
<p>软件测试分为：</p>
<ul>
<li>单元测试</li>
<li>集成测试</li>
<li>系统测试</li>
<li>验收测试</li>
</ul>
</li>
<li>
<p>每一个测试活动有5个过程：</p>
<ul>
<li>测试计划制定、测试设计、测试样例生成、测试实施、测试报告</li>
</ul>
</li>
</ul>
<h3 id="第七章-需求分析方法">第七章 需求分析方法</h3>
<ul>
<li>
<p>类的外部关联有3中关系</p>
<ul>
<li>关联</li>
<li>继承</li>
<li>依赖</li>
</ul>
</li>
<li>
<p>事件跟踪图</p>
<ul>
<li>表示事件顺序和事件和对象的关系</li>
<li>时间从上到下递增</li>
</ul>
</li>
</ul>
<h3 id="第十一章-软件项目管理方法">第十一章 软件项目管理方法</h3>
<ul>
<li>
<p>软件项目管理和软件工程的区别和关系：</p>
<ul>
<li>目标相同：都是围绕软件产品开发的管理</li>
<li>作用不同：软件工程是软件开发的方法论，软件项目管理是生产管理形式。</li>
<li>关联：软件项目管理是软件工程的载体</li>
</ul>
</li>
<li>
<p>度量方法</p>
<ul>
<li>代码行度量</li>
<li>功能点度量</li>
</ul>
</li>
</ul>
<h3 id="第十三章-软件配置">第十三章 软件配置</h3>
<ul>
<li>
<p>风险识别3步：</p>
<ul>
<li>资料收集</li>
<li>估计项目风险形式</li>
<li>识别风险</li>
</ul>
</li>
<li>
<p>软件质量：</p>
<ul>
<li>提供的软件产品满足用户的明确和隐含需求的能力特性总和。</li>
</ul>
</li>
<li>
<p>软件配置管理中的基本单元：软件配置项</p>
<ul>
<li>软件的文档、程序、数据进行整合
<ul>
<li>以利于软件的定义、标识、跟踪、管理，使其成为受控的软件版本产品</li>
<li>这一过程成为软件配置管理</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="第十四章-软件维护">第十四章 软件维护</h3>
<ul>
<li>
<p>软件维护的工作程序与软件开发的工作程序相仿</p>
<ul>
<li>维护的需求分析</li>
<li>维护的设计</li>
<li>修改程序代码</li>
<li>维护后的测试</li>
<li>维护后的试运行</li>
<li>维护后的正式运行</li>
<li>维护过程的评审和审计</li>
</ul>
</li>
<li>
<p>面向缺陷维护的内容</p>
<ul>
<li>该产品正常运行，但是个别地方存在缺陷。</li>
<li>用户不满意，克服缺陷的方法是修改程序。</li>
<li>修改程序而不修改结构</li>
</ul>
</li>
<li>
<p>文档是指记录数据的媒体和数据本身。</p>
<ul>
<li>永久性</li>
<li>描述人工可读的东西</li>
<li>表述活动、需求、过程或结果的描述、定义、规定或认证。</li>
<li>规定了实现的细节。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[《思维导图》读书笔记]]></title>
        <id>https://blog.leepanda.top/post/lesslesssi-wei-dao-tu-greatergreater-du-shu-bi-ji/</id>
        <link href="https://blog.leepanda.top/post/lesslesssi-wei-dao-tu-greatergreater-du-shu-bi-ji/">
        </link>
        <updated>2021-05-29T11:16:56.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前言">前言</h3>
<p>为了加强记忆，学习了《思维导图》一书。<br>
该书认为应当 使用 <code>线条自然</code>、<code>横向</code>、<code>色彩绚丽</code>、<code>以图形表意</code> 的 思维导图 来帮助记录知识点。<br>
我根据自己的需要，用思维导图记录了书中介绍的，<code>高效记忆方法</code> 和 <code>问题分析方法</code></p>
<h3 id="高效记忆">高效记忆</h3>
<p><img src="https://img-blog.csdnimg.cn/20210311002216762.png" alt="RAM" loading="lazy"><br>
高效记忆的留个关键技巧 图中从12点方向逆时针分别是</p>
<ul>
<li>专注：全神贯注地做事，感受</li>
<li>理解：对事件充分理解，感受细节</li>
<li>重复：一段时间后重复记忆</li>
<li>联动：离散的知识点之间联想。增强记忆</li>
<li>感官：场景可以与感官联动。比如恋人的气味。</li>
<li>情景：向知识点中加入故事情节。</li>
</ul>
<h3 id="思考能力-提升">思考能力 提升</h3>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20210311002240436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NlbWFvNDU0OA==,size_16,color_FFFFFF,t_70" alt="CPU" loading="lazy"></figure>
<p>对于一个命题，可以分析的方向如下:</p>
<ul>
<li>抽象</li>
<li>比较</li>
<li>分类</li>
<li>解析</li>
<li>集成</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[合约安全[4]:为啥说UniswapK值不那么守恒]]></title>
        <id>https://blog.leepanda.top/post/he-yue-an-quan-4wei-sha-shuo-uniswapk-zhi-bu-na-me-shou-heng/</id>
        <link href="https://blog.leepanda.top/post/he-yue-an-quan-4wei-sha-shuo-uniswapk-zhi-bu-na-me-shou-heng/">
        </link>
        <updated>2021-05-29T11:15:39.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>诶嘿，刚审计了个Swap项目，项目的Swap函数手续费收了两次...<br>
为了把问题描述的清晰一些，我仔细地追了一下swap中手续费的计算方法。</p>
<p>于是机缘巧合的发现了<code>Uniswap</code> K值检查的奇妙，和我想象中的检查方式有些差别。<br>
本文做一个技术点的记录和分享。</p>
<p><ul class="markdownIt-TOC">
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86">前置知识</a>
<ul>
<li><a href="#amm%E7%9A%84k%E5%80%BC%E5%AE%88%E6%81%92">AMM的K值守恒</a></li>
</ul>
</li>
<li><a href="#%E9%97%AE%E9%A2%98%E5%8F%91%E7%8E%B0">问题发现</a><br>
*
<ul>
<li><a href="#%E4%B8%BA%E5%95%A5%E4%B8%8D%E6%98%AF%E5%B0%8F%E4%BA%8Ek%E5%80%BC">为啥不是小于K值</a></li>
<li><a href="#%E4%B8%BA%E5%95%A5%E8%BF%98%E8%83%BD%E5%A4%A7%E4%BA%8Ek%E5%80%BC">为啥还能大于K值</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E7%A2%8E%E7%A2%8E%E5%BF%B5">碎碎念</a></li>
<li><a href="#%E5%BC%95%E7%94%A8">引用</a></li>
</ul>
</p>
<h1 id="前置知识">前置知识</h1>
<h2 id="amm的k值守恒">AMM的K值守恒</h2>
<p>在AMM中进行交易，遵循K值守恒原则，Swap前后的reverse乘积不变。<br>
详细兑换原理，可查看 <a href="https://hackmd.io/@HaydenAdams/HJ9jLsfTz#Example-ETH-%E2%86%92-OMG">uniswap解析与举例</a></p>
<h1 id="问题发现">问题发现</h1>
<p>在描述问题过程之前，笔者奉上<code>UniswapV2Pair:swap</code>的代码以便查阅:</p>
<pre><code class="language-javascript">    // this low-level function should be called from a contract which performs important safety checks
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock {
        require(amount0Out &gt; 0 || amount1Out &gt; 0, 'UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT');
        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
        require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, 'UniswapV2: INSUFFICIENT_LIQUIDITY');

        uint balance0;
        uint balance1;
        { // scope for _token{0,1}, avoids stack too deep errors
        address _token0 = token0;
        address _token1 = token1;
        require(to != _token0 &amp;&amp; to != _token1, 'UniswapV2: INVALID_TO');
        if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
        if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
        if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
        balance0 = IERC20Uniswap(_token0).balanceOf(address(this));
        balance1 = IERC20Uniswap(_token1).balanceOf(address(this));
        }
        uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
        uint amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
        require(amount0In &gt; 0 || amount1In &gt; 0, 'UniswapV2: INSUFFICIENT_INPUT_AMOUNT');
        { // scope for reserve{0,1}Adjusted, avoids stack too deep errors
        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
        require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
        }

        _update(balance0, balance1, _reserve0, _reserve1);
        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
    }
</code></pre>
<p>根据AMM的K值守恒要求，当Swap完成时，uniswap底层应检查一下K值是否与交易前相等。<br>
代码大概是 <code>balance0 * balance1 == K</code>这样子，至少应该是个<code>等于号</code>。<br>
但是当我们跟进到<code>UniswapV2Pair:swap</code>函数时，发现检查K值守恒的用的是<code>&gt;=</code>号，对应代码是</p>
<pre><code class="language-javascript">require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
</code></pre>
<p>嘿嘿，神奇啊。这和预期的K值守恒完全不是一个意思呀。<br>
带着充满好奇的满心欢喜，我们瞅瞅上面代码是咋写的。<br>
等号左边儿咋害能比K值大呢?</p>
<pre><code class="language-javascript">        uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
        uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
</code></pre>
<p>瞅这两行，<code>balance0Adjusted</code>和<code>balance1Adjusted</code>是pair新余额的校准值。<br>
校准的部分是刨去手续费的<code>amountIn</code>。<br>
看到这里我就更懵了: 这一Adjust后，balance更小了。<br>
这乘积肯定比K值小啊，咋害能大呢。</p>
<h3 id="为啥不是小于k值">为啥不是小于K值</h3>
<p>我们仔细看一下<code>amountIn</code>的来源，</p>
<pre><code class="language-javascript">uint amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
</code></pre>
<p>可见<code>amountIn</code> 是 <code>真实balance - (reverse - amountOut)</code><br>
所以<code>amountIn</code> 的含义是 <code>真实的输入量</code>，即包含<code>0.3%</code>手续费的那个<code>100%AmountIn</code>。</p>
<p>这么一看我就悟了。<br>
哦，我的老伙计。<br>
用户把钱打进来的地方可是在swap函数调用之前呀。<br>
如<code>UniswapV2Router02.sol:swapExactTokensForTokens</code>:</p>
<pre><code class="language-javascript">    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {
        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
        require(amounts[amounts.length - 1] &gt;= amountOutMin, 'UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT');
        TransferHelper.safeTransferFrom(
            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
        );
        _swap(amounts, path, to);
    }
</code></pre>
<ul>
<li>打钱的地方是<code>TransferHelper.safeTransferFrom</code></li>
<li>这时候<code>balance</code>发生变化，增加了<code>100%AmountIn</code></li>
<li>但是下面<code>_swap</code>兑换的时候，用的<code>AmountOut</code>是<code>getAmountOut</code>return的那个<code>99.7%AmountOut</code>。</li>
<li>剩余的<code>0.3%feeValue</code>被留在了pair里面，造成了输入币<code>reverse</code>的增大。</li>
</ul>
<p>后面<code>pair.swap</code>时，通过<code>校准</code>将这<code>0.3%</code>异常抹除。<br>
这时再比较K值，就不是小于而是相等啦。</p>
<h3 id="为啥还能大于k值">为啥还能大于K值</h3>
<p>ok <code>不是小于而是相等</code>的问题解决了。<br>
剩下就是 <code>Uniswap</code>为啥还留了个<code>大于号</code>。</p>
<pre><code class="language-javascript">require(balance0Adjusted.mul(balance1Adjusted) &gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), 'UniswapV2: K');
</code></pre>
<p>要搞清楚这个问题，我们需要回到Uniswap第一次开始检查<code>K值守恒</code>的时间点:<br>
<code>commit:580787051ed66b75210c14269a3a48b4bcdee620</code></p>
<p>在这个版本中，人类历史上首次提出了<code>&quot;UniswapV2: K&quot;</code>的要求</p>
<pre><code class="language-javascript">        } else {
            ...
            require(amountIn.mul(reserve0 - amountOut).mul(997) &gt;= amountOut.mul(reserve1).mul(1000), &quot;UniswapV2: K&quot;);
            ...
        }
</code></pre>
<p>哭辽，原来<code>swap方法</code>从一开始就没想过<code>等价交换</code>或者什么<code>K值守恒</code><br>
它只是要求 扣除手续费后的<code>AmountIn</code> 要大于等于 取走的<code>AmountOut</code><br>
换句话说:<br>
<strong>你往<code>pair</code>里面多扔钱我不拦着；想多拿走?绝不可能!(╬￣皿￣)=○</strong></p>
<h1 id="总结">总结</h1>
<p>这么一追，我悟了。<br>
<code>&gt;=</code>设计本身就是一个合约的利己行为。<br>
Swap的K值守恒也只是限制<code>user</code>别换走额外的钱，<br>
但你要是无偿提供点流动性，本合约绝不拦你~ ╰(￣▽￣)╭</p>
<h1 id="碎碎念">碎碎念</h1>
<p>使用<code>&gt;=</code>而不是<code>==</code>，放宽了K值守恒的限制，<br>
这意味着攻击者有了更多的操作空间。<br>
至于能怎么利用这个<code>小trick</code>，以后再想吧...</p>
<h1 id="引用">引用</h1>
<ul>
<li><a href="https://hackmd.io/@HaydenAdams/HJ9jLsfTz#Providing-Liquidity">Uniswap Whitepaper</a></li>
<li><a href="https://github.com/Uniswap/uniswap-v2-core/">Uniswap Core</a></li>
<li><a href="https://github.com/Uniswap/uniswap-v2-periphery">Uniswap Periphery</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[合约安全[3]: BurgerSwap重入漏洞]]></title>
        <id>https://blog.leepanda.top/post/he-yue-an-quan-3-burgerswap-chong-ru-lou-dong/</id>
        <link href="https://blog.leepanda.top/post/he-yue-an-quan-3-burgerswap-chong-ru-lou-dong/">
        </link>
        <updated>2021-05-29T11:14:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>2020年10月22日，<a href="https://burgerswap.org">Zengo</a>团队的Oded Leiba，发表了他在<a href="https://burgerswap.org">BurgerSwap</a>中发现的<a href="https://zengo.com/burgerswap-vulnerability/">重入漏洞</a>。<br>
本文将翻译并解读漏洞的原理。</p>
<p><ul class="markdownIt-TOC">
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86">基础知识</a>
<ul>
<li><a href="#amm">AMM</a></li>
<li><a href="#%E6%B5%81%E5%8A%A8%E6%80%A7">流动性</a></li>
<li><a href="#%E5%B8%81%E5%AF%B9">币对</a></li>
<li><a href="#weth">WETH</a></li>
</ul>
</li>
<li><a href="#%E6%BC%8F%E6%B4%9E%E6%A6%82%E8%BF%B0">漏洞概述</a></li>
<li><a href="#%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86">漏洞原理</a></li>
<li><a href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88">修复方案</a>
<ul>
<li><a href="#checks-effects-interactions-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83">Checks-Effects-Interactions 编码规范</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E9%94%81-lock-modifier">函数锁 lock modifier</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
<li><a href="#%E5%BC%95%E7%94%A8">引用</a></li>
</ul>
</p>
<h1 id="基础知识">基础知识</h1>
<h2 id="amm">AMM</h2>
<p>自动做市商(AMM)是一种即时兑换模式。<br>
通常的交易所(中心化/去中心化)，需要买卖双方对价格达成一致，才能完成交易；<br>
而AMM 只需买方认可流通池中的Token价格即可立刻完成交易。</p>
<h2 id="流动性">流动性</h2>
<p>用户将资产转入交易平台之中获得收益，而在平台中的总资产额度，就构成了流通池。<br>
流通池中代币总额越多，深度越好，大额交易带来的影响也就更小，不至于因为一笔几十万美元的交易就让价格产生大幅波动。<br>
Defi的一个风险点就是流通池不够大，容易产生较大滑点。</p>
<h2 id="币对">币对</h2>
<p>币对是用于记录流通池相关信息的变量。<br>
例如，用户想使用<code>A</code>币换取<code>B</code>币，那么就会涉及到币对 <code>A-B</code>。<br>
用户将一些<code>A</code>币转入币对<code>A-B</code>中，并从中取出若干<code>B币</code>，即可完成兑换。<br>
币对<code>A-B</code>中可被取出的<code>A</code>币和<code>B</code>币总量，就对应着币对的<code>流动性</code>。<br>
剩余币总量越大，<code>流动性</code>越大。</p>
<h2 id="weth">WETH</h2>
<p>为了让ETH能跟其他ERC20标准的Token进行交易，<br>
实现了满足ERC20标准的WETH合约，作为ETH和Token之间兑换的桥梁。</p>
<h1 id="漏洞概述">漏洞概述</h1>
<p>这是一个典型的<a href="https://swcregistry.io/docs/SWC-107">重入漏洞</a>，<br>
攻击者只需付出少量的ETH、一点点<code>WETH-BSC</code>流动性，即可掏空<code>WETH-BSC</code>币对中所有的ETH。</p>
<h1 id="漏洞原理">漏洞原理</h1>
<p>漏洞出现在<code>withdrawFromBSC</code>方法中,<br>
该方法用于赎回<code>Token</code>或<code>ETH</code></p>
<pre><code class="language-javascript">    function withdrawFromBSC(bytes calldata _signature, bytes32 _paybackId, address _token, uint _amount) external payable {
        require(executedMap[_paybackId] == false, &quot;ALREADY_EXECUTED&quot;);
        
        require(_amount &gt; 0, &quot;NOTHING_TO_WITHDRAW&quot;);
        require(msg.value == developFee, &quot;INSUFFICIENT_VALUE&quot;);
        
        bytes32 message = keccak256(abi.encodePacked(_paybackId, _token, msg.sender, _amount));
        require(_verify(message, _signature), &quot;INVALID_SIGNATURE&quot;);
        
        if(_token == WETH) {
            IWETH(WETH).withdraw(_amount);
            TransferHelper.safeTransferETH(msg.sender, _amount);
        } else {
            TransferHelper.safeTransfer(_token, msg.sender, _amount);
        }
        totalFee = totalFee.add(developFee);
        
        executedMap[_paybackId] = true;
        
        emit Withdraw(_paybackId, msg.sender, _token, _amount);
    }
</code></pre>
<ol>
<li>函数先检查了<code>executedMap[_paybackId]</code>是否为<code>false</code>，从而判断这笔赎回交易是否已经被处理。</li>
<li>然后检查了用户所支付的<code>feeValue</code>数量和提供的<code>签名</code>是否有效。</li>
<li>接着便是调用<code>TransferHelper</code>进行转账操作。</li>
<li>最后更改<code>executedMap[_paybackId]</code>的值为<code>true</code>，以表明该赎回交易处理完成。</li>
</ol>
<p>到这里，漏洞的本质就浮出水面了。<br>
<strong><code>withdrawFromBSC</code>方法的实现，没有遵循<code>Checks-Effects-Interactions</code>编码规范。</strong></p>
<p>根据<a href="https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html">CEI规范</a>合约函数在实现时，应该</p>
<ol>
<li>先检查输入是否符合条件</li>
<li>再修改合约状态</li>
<li>最后和用户交互<br>
举个正确的例子:</li>
</ol>
<pre><code class="language-javascript">    function withdraw(uint amount) public {
        require(balances[msg.sender] &gt;= amount);

        balances[msg.sender] -= amount;

        msg.sender.transfer(amount);
    }
</code></pre>
<p>很明显，对于<code>withdrawFromBSC</code>方法<br>
<code>调用TransferHelper进行转账</code>的操作, 应发生在<code>executedMap[_paybackId] = true;</code>之后。</p>
<p>由于<code>TransferHelper.safeTransferETH</code>的实现，使用的是原生的<code>.call.value</code>方法。</p>
<pre><code class="language-javascript">    function safeTransferETH(address to, uint value) internal {
        (bool success,) = to.call{value:value}(new bytes(0));
        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');
    }
</code></pre>
<p>函数调用者的<code>fallback</code>方法将会被调用，<br>
攻击者合约可以通过实现<code>fallback</code>方法，并在其中再次调用<code>withdrawFromBSC</code>来实现重入攻击。<br>
转走<code>BurgerSwap</code>合约中所有的<code>ETH</code>。</p>
<h1 id="修复方案">修复方案</h1>
<h2 id="checks-effects-interactions-编码规范">Checks-Effects-Interactions 编码规范</h2>
<p>最有效、简单的解决方案，就是将<code>withdrawFromBSC</code>方法中的</p>
<pre><code class="language-javascript">        if(_token == WETH) {
            IWETH(WETH).withdraw(_amount);
            TransferHelper.safeTransferETH(msg.sender, _amount);
        } else {
            TransferHelper.safeTransfer(_token, msg.sender, _amount);
        }
</code></pre>
<p>放到<code>executedMap[_paybackId] = true;</code>之后。<br>
只要符合CEI规范，攻击合约就会因为通不过check，而无法改变函数控制流。</p>
<h2 id="函数锁-lock-modifier">函数锁 lock modifier</h2>
<p>通过实现一个<code>lock modifier</code>来添加函数锁概念。<br>
当在交易中第一次进入函数时，<br>
更新全局变量<code>lock</code>的值,使得<code>modifier</code>验证无法通过<br>
从而限制函数之间的相互调用。</p>
<p>简单举例如下:</p>
<pre><code class="language-javascript">pragma solidity ^0.4.0;

contract SingleCall {
  address public lock = false;

  modifier onlyOnce {
    if (this.lock != false) throw;
    _;
  }

  function withdrawFromBSC(bytes _someParams)
  onlyOnce
  {
    lock = true;
    //some command...;
    lock = false;
  }
}
</code></pre>
<h1 id="总结">总结</h1>
<p><code>BurgerSwap</code>合约由于没有遵循<code>Checks-Effects-Interactions 编码规范</code>，导致了严重的重入漏洞。<br>
作为合约的开发人员，应以此为戒，把<code>用户交互</code>放到<code>修改合约状态</code>后面。<br>
同时，不要盲目相信市面上第三方代码的实现。<br>
也许底层函数本身没有问题，却由于开发时不安全地调用，引入了风险。</p>
<p>另一方面，合约项目方可以通过赏金计划、漏洞平台等方式吸引社区中的白帽黑客来发现项目中的安全漏洞<br>
帮助项目的完善和安全性的提升。<br>
最后，项目方可以联系国内有<code>区块链合约安全</code>相关服务的厂家(比如<a href="https://www.chaitin.cn/zh/review">长亭科技</a>)来支持代码审计工作，对项目进行系统、全面的安全性检查。</p>
<h1 id="引用">引用</h1>
<ul>
<li><a href="https://leepanda.blog.csdn.net/article/details/107137462">合约安全(1):Balancer中通货紧缩货币的套利攻击详解</a></li>
<li><a href="https://zengo.com/burgerswap-vulnerability/">Reentering the Reentrancy Bug: Disclosing BurgerSwap’s Vulnerability</a></li>
<li><a href="https://etherscan.io/address/0xaf5dcebba2f8bec8729117336b2fe8b4e0d99b0b#code">Source Code of BurgerSwap</a></li>
<li><a href="https://swcregistry.io/docs/SWC-107">SWC-107 Reentrancy</a></li>
<li><a href="https://consensys.github.io/smart-contract-best-practices/known_attacks/">Ethereum Smart Contract Best Practices#Reentrancy</a></li>
<li><a href="https://fravoll.github.io/solidity-patterns/checks_effects_interactions.html">solidity-patterns Checks Effects Interactions</a></li>
<li><a href="https://www.chaitin.cn/">长亭科技 Chaitin</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[所有基于cosmos的区块链项目的测试网启动方法]]></title>
        <id>https://blog.leepanda.top/post/suo-you-ji-yu-cosmos-de-qu-kuai-lian-xiang-mu-de-ce-shi-wang-qi-dong-fang-fa/</id>
        <link href="https://blog.leepanda.top/post/suo-you-ji-yu-cosmos-de-qu-kuai-lian-xiang-mu-de-ce-shi-wang-qi-dong-fang-fa/">
        </link>
        <updated>2021-05-29T11:13:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="abstract">Abstract</h1>
<p>基于cosmos框架的区块链项目，在启动脚本上都大同小异。<br>
这里做一下整理记录。方便后面的测试使用。</p>
<h1 id="genesis-file-format">genesis file format</h1>
<h3 id="init">init</h3>
<p><code>serverd init --gen-txs --home=$HOME/.gaiad1 --chain-id=test-chain</code></p>
<h3 id="gentx">gentx</h3>
<p><code>serverd gentx --name validator --amount 1000000000ucsdt</code></p>
<h3 id="add-genesis-account">add-genesis-account</h3>
<p><code>serverd add-genesis-account $(client keys show validator -a) 10000000000ucsdt</code></p>
<h3 id="collect-gentxs">Collect-gentxs</h3>
<p><code>serverd collect-gentxs</code></p>
<h3 id="start">start</h3>
<p><code>serverd start</code></p>
<h1 id="总结">总结</h1>
<p>这边用<code>xar-network</code>来举例</p>
<pre><code class="language-shell"># You can run all of these commands from your home directory
cd $HOME

# Initialize the genesis.json file that will help you to bootstrap the network
xard init --chain-id=testing testing

# Create a key to hold your validator account
xarcli keys add validator

# Add that key into the genesis.app_state.accounts array in the genesis file
# NOTE: this command lets you set the number of coins. Make sure this account has some coins
# with the genesis.app_state.staking.params.bond_denom denom, the default is staking
xard add-genesis-account $(xarcli keys show validator -a) 10000000000000uftm,10000000000ucsdt

# Generate the transaction that creates your validator
xard gentx --name validator --amount 1000000000ucsdt

# Add the generated bonding transaction to the genesis file
xard collect-gentxs

# Now its safe to start `xard`
xard start

</code></pre>
<p>这样就初始化了 validator并给了一些初始代币。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GoFuzz自定义语料输入流程记录]]></title>
        <id>https://blog.leepanda.top/post/gofuzz-zi-ding-yi-yu-liao-shu-ru-liu-cheng-ji-lu/</id>
        <link href="https://blog.leepanda.top/post/gofuzz-zi-ding-yi-yu-liao-shu-ru-liu-cheng-ji-lu/">
        </link>
        <updated>2021-05-29T11:11:21.000Z</updated>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>在使用gofuzz的过程中，发现自己输入的corpus好像没有被执行。<br>
遂审计一下代码，追踪一下输入的corpus的处理流程。</p>
<h1 id="正文">正文</h1>
<p>在一次测试过程中，我输入的初始语料如下</p>
<pre><code>{&quot;Name&quot;:&quot;AjWwhT&quot;,&quot;Symbol&quot;:&quot;HctcuA&quot;,&quot;TotalSupply&quot;:100}
</code></pre>
<p>但进化出的可崩溃语料却是这些</p>
<pre><code>        &quot;:&quot;
        &quot;{\&quot;\&quot;1&quot;
        &quot;{1&quot;
        &quot;{:&quot;
        &quot;\&quot;\&quot;,&quot;
        &quot;\&quot;\&quot;:&quot;
        &quot;{0&quot;
        &quot;{,&quot;
        &quot;,&quot;
        &quot;{2&quot;
        &quot;{\&quot;\&quot;:0\&quot;0&quot;
        &quot;{\&quot;\&quot;T&quot;
        &quot;0T&quot;
        &quot;0\&quot;0&quot;
        &quot;{\&quot;\&quot;2&quot;
        &quot;{\&quot;\&quot;\&quot;&quot;
        &quot;{T&quot;
        &quot;{\&quot;\&quot;}&quot;
        &quot;{\&quot;\&quot;:\&quot;\&quot;:&quot;
        &quot;{\&quot;\&quot;:\&quot;\&quot;T&quot;
        &quot;{\&quot;\&quot;,&quot;
        &quot;02&quot;
        &quot;{}&quot;
        &quot;}&quot;
        &quot;T&quot;
        &quot;{\&quot;\&quot;:00&quot;
        &quot;01&quot;
        &quot;0}&quot;
        &quot;00&quot;
        &quot;{\&quot;\&quot;0&quot;
</code></pre>
<p>这都是嘛玩意儿，根本看不出跟我的初始输入有啥血缘关系。<br>
于是跟进一下代码，来学习一下corpus的处理流程。</p>
<h3 id="文件输入">文件输入</h3>
<p><code>go-fuzz</code>命令的入口为<code>main</code>函数。<br>
其中，调用了<code>coordinatorMain</code>和<code>hub.connect</code>函数。</p>
<ul>
<li><code>coordinatorMain</code>函数从<code>/corpus/</code>文件目录下读取用户生成的自定义初始语料集合。</li>
<li><code>hub.connect</code>函数将这些语料集合载入到变量<code>hub.triageQueue</code>中。</li>
</ul>
<p>工作进程包含两个循环:</p>
<ul>
<li><code>hub.loop</code>: 该循环将<code>hub.triageQueue</code>中的语料载入到<code>triageC</code>变量中。</li>
<li><code>worker.loop</code>:该循环调用<code>triageInput</code>函数来处理<code>triageC</code>变量。</li>
</ul>
<p>流程图如下:<br>
<img src="https://img-blog.csdnimg.cn/20200821235626249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NlbWFvNDU0OA==,size_16,color_FFFFFF,t_70#pic_center" alt="gofuzz 输入流程图" loading="lazy"></p>
<h1 id="结尾">结尾</h1>
<p>所以说gofuzz还是运行了我给的初始corpus，只是由于某种原因没有输出crash...<br>
可能是没有当作模糊测试的重点？<br>
这些都只是猜测<br>
我不想花太多时间在研究如何优雅的使用gofuzz上了。<br>
于是直接到gofuzz仓库的issue中寻找答案。<br>
在<a href="https://github.com/dvyukov/go-fuzz/issues/289">issue#289</a>中，找到了类似的思考。<br>
官方给出的更优解是<a href="https://github.com/thepudds/fzgo">fzgo</a>,一个集成了go-fuzz和go test的工具。</p>
<p>后面我会把研究精力，从gofuzz的原理研究 转移到 fzgo的体验和测试上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[GoFuzz无法正常触发crash研究]]></title>
        <id>https://blog.leepanda.top/post/gofuzz-wu-fa-zheng-chang-hong-fa-crash-yan-jiu/</id>
        <link href="https://blog.leepanda.top/post/gofuzz-wu-fa-zheng-chang-hong-fa-crash-yan-jiu/">
        </link>
        <updated>2021-05-29T11:09:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="abstract">Abstract</h1>
<p>在使用gofuzz测试的过程中。<br>
遇到明明很有问题、肯定能触发panic的语料，却没有生成对应的crash。<br>
怀疑自己的使用姿势不对，遂对其进行了研究。本文记录一下实验过程和结果。</p>
<p>为了方便测试，设计了自定义Fuzz函数如下:<br>
<img src="https://img-blog.csdnimg.cn/20200821104633265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NlbWFvNDU0OA==,size_16,color_FFFFFF,t_70#pic_center" alt="panic测试" loading="lazy"><br>
通过测试panic是否会崩溃，来检查panic和return值之间的相关性。</p>
<h3 id="猜测1-fuzz函数return值存在特殊含义">猜测1: Fuzz函数return值存在特殊含义</h3>
<p>为了测试return值对fuzz过程的影响，我删去了panic的设计。<br>
当改变return的返回值时，fuzz的exec(程序执行次数) corpus(进化出的语料) restarts(程序重启次数)发生了如下的变化。</p>
<pre><code>return之间的影响 (无panic)
仅return1
exec+ corpus+ restarts+
仅return 0 
exec+ corpus+ restarts+
仅return -1
exec+ corpus1 restarts+
</code></pre>
<p>可以看出在gofuzz中，Fuzz函数的return值有特殊的含义。</p>
<ul>
<li>return 1 : 表示这次测试的样例是好的，成功的，阳性的。请多多使用这个突变分支的样例来测试。</li>
<li>return 0 : 表示这次测试样例正常，挺好的。就继续测吧，对后续测试样例的使用没有影响。</li>
<li>return -1: 表示这次测试使用的样例不给力，成阴性。在以后的测试中，减少这个突变分支的测试样例。</li>
</ul>
<blockquote>
<p>由于我使用gofuzz测试的目的，就是为了找出让程序无法正常执行的输入样例。因此，这里会自然的想到使用panic 配合 return 1.来实现: 发现crash的同时，能让后面的fuzz过程找到更多 Panic样例。</p>
</blockquote>
<h3 id="猜测2-不同return的值-和-panic组合可能产生不同结果-导致不panic">猜测2: 不同return的值 和 panic组合，可能产生不同结果。导致不panic</h3>
<p>我通过修改33line的那个<code>return</code>值，来测试panic函数无法正常崩溃 是否和 return的值相关。<br>
测试结果如下</p>
<pre><code>-1 不crash
0 不crash
1 不crash
</code></pre>
<ul>
<li>看来和return的值没有关系。</li>
</ul>
<h3 id="猜测3-同一个block中panic和return不能一起使用">猜测3: 同一个block中，panic和return不能一起使用</h3>
<p>首先编写一个简单的测试程序，代码如下:<br>
<img src="https://img-blog.csdnimg.cn/20200821111315523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NlbWFvNDU0OA==,size_16,color_FFFFFF,t_70#pic_center" alt="crash的代码" loading="lazy"><br>
其中第16line的panic理论上必然触发<br>
测试后发现果然<code>触发了crash</code></p>
<p>于是我们在panic后面17line的位置添加<code>return true</code><br>
<img src="https://img-blog.csdnimg.cn/20200821111513448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NlbWFvNDU0OA==,size_16,color_FFFFFF,t_70#pic_center" alt="不crash的代码" loading="lazy"><br>
<strong>测试发现，没有报错。在同一个block中，panic后面不能有return</strong></p>
<h3 id="猜测4-panic和fuzz函数默认return之间的影响">猜测4: panic和Fuzz函数默认return之间的影响</h3>
<p>在Fuzz函数中，如果自定义了panic点。则Fuzz函数的默认返回值必须唯一。<br>
为了证实这一点，做了如下实验。</p>
<pre><code class="language-go">func Fuzz(data []byte) int {
	err := receivedCorpus(data)
	fmt.Println(err)
	if err != false {
		panic(&quot;22&quot;)
	}
	return 0
}
</code></pre>
<p>通过改变return 的返回值，来检查该值和panic之间的关系。<br>
实验结果如下:</p>
<pre><code>默认return 0
不 crash
默认return 1
crash
默认return -1
不crash
</code></pre>
<h1 id="总结">总结</h1>
<p>经过测试，在gofuzz中使用panic来触发崩溃时，</p>
<ul>
<li>不能在panic后面直接跟return。否则会没有crash。</li>
<li>另外，Fuzz函数的默认返回值必须是1，否则不会崩溃。</li>
</ul>
]]></content>
    </entry>
</feed>